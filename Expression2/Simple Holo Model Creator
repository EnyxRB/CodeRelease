@name Simple Holo Model Creator
@inputs
@outputs 
@persist CurHolo Index [Holos HoloPos HoloAng HoloScale HoloColor HoloModel HoloMaterial HoloAlpha]:array Inc Mode LastHolo 
@persist CurIndex LastIndex Slave:entity [QMark Code Filename CopyMat CopyModel]:string IncAng Version:string MirrorIndex
@persist [CopyColor CopyScale CopyPos]:vector CopyAng:angle CopyAlpha GitCode:string UpdateOption
@trigger 

"----------------------------------------------------------------------------------------------------"
"####################################################################################################"
"##      ######     #####  ######  ########  #####  ######  #############       ######     ##########"
"##  ##########  #  #####  #######  ######  #######  ####  ##############  #########  ####  #########"
"##  ##########  ##  ####  ########  ####  #########  ##  ###############  ###############  #########"
"##      ######  ###  ###  #########  ##  ###########    ################       #########  ##########"
"##  ##########  ####  ##  ##########   ############  ##  ###############  #########   ##############"
"##  ##########  #####  #  ##########   ###########  ####  ##############  #########  ###############"
"##      ######  ######    ##########   ##########  ######  #############       ####        #########"
"####################################################################################################"
"----------------------------------------------------------------------------------------------------"

#TODO: (new) Holo Procedural spawn, (new) common materials list to search keywords e.g. -mat 1.

#---------------------------------COMMANDS---------------------------------#
#   -i model : creates a new hologram with said model
#   -delete : deletes the current hologram from the program
#   -inc number : e.g. -inc 5. sets the incremental for move/scale mode to number (starting 6)
#   -inc ang number : e.g. -inc ang 45. sets the incremental for angling mode to said number (starting 45)
#   -move : changes the current mode to move mode, allowing movement with keys
#   -move x,y,z : moves the current hologram to given x,y,z coordinates
#   -move reset : resets the position of the current hologram back to starting position
#   -scale : changes the current mode to scale mode, allowing unit scaling with keys
#   -scale reset : resets the scale of the current hologram
#   -scale double : doubles the current scale of the current hologram
#   -scale half : halves the current scale of the current hologram
#   -scale x,y,z : changes the unit scale of the current hologram to vec(x,y,z). Same as holoScaleUnits()
#   -scalem x,y,z : changes the multplier scale of the current hologram vec(x,y,z). Same as holoScale()
#   -ang : changes the current mode to angling mode, allowing angling with keys
#   -ang p,y,r : changes the current angles to the said pitch,yaw and roll
#   -ang reset : resets the angle of the current hologram to it's starting angle
#   -color R,G,B : e.g. -color 255,0,0. changes the color of the current hologram to said color values
#   -alpha number : changes the alpha of the current hologram to said number
#   -mat material : changes the holograms material to the said material
#   -mirror direction (forward/right/up) : creates a mirrored hologram around the e2 across the said plane
#   -copy model/pos/scale/ang/color/mat/alpha : copies said value of properties of current hologram
#   -paste model/pos/scale/ang/color/mat/alpha : pastes the last copied value onto the curent hologram
#   -dupe : duplicates the current selected hologram in the exact same position
#   -finish filename: sets the code required to spawn your creation in the slave e2 and changes slave name to said filename
#--------------------------------------------------------------------------#

#---------------------------------CONTROLS---------------------------------#
#   numpad8 = move holo forward /pitch holo down
#   numpad5 = move holo backward/pitch holo up
#   numpad4 = move holo left/yaw holo left
#   numpad6 = move holo right/yaw holo right
#   numpad- = move holo up/roll holo left
#   numpad+ = move holo down/roll holo right
#   numpad/ = cycles to the previous hologram in the program
#   numpad* = cycles to the next hologram in the program
#--------------------------------------------------------------------------#

#-------------------------------INSTRUCTIONS-------------------------------#
#1. Place the Simple Holo Model Creator E2 on the ground
#2. Place the Simple Holo Model Creator Slave E2 on the ground
#3. Make your creation using the commands and controls above
#4. Type -finish followed by the filename you wish the E2 to have
#5. Right click on the placed slave E2 and save it
#6. Got yourself a holo model
#--------------------------------------------------------------------------#

#--------------------------------SLAVE CODE--------------------------------#
#If you don't have the slave chip already, simply copy the code below into a E2 and follow the instructions.
#[
@name Simple Holo Model Creator Slave
@inputs 
@outputs 
@persist Boss:entity
@trigger 

if (first() | dupefinished()){
    Boss = dsProbe("holoCreator")[1,entity]
    dsJoinGroup("holoCreator")
    dsSendDirect("init",Boss,0)    
}
]#

#---------------------------------CHANGELOG---------------------------------#
#--------------------------------VERSION 1.1--------------------------------#
#(new) Added seperate incremental for angling so angling inc can start at 90.
#(new) New command -inc ang number to change the incremental of angling.
#(new) Added name update on creating and deleting holos, to show user the number of holos active.
#(fix) On deleting holos until last holo remains, bug whereby last hologram couldn't be selected.
#(new) Switches to angling mode upon using -inc ang command, aswell as setting the ang inc.
#(new) Added mirror function -mirror direction (forward/right/up) allowing to mirror holograms across planes.
#(change) Changed control layout to make moving/scaling/angling holograms more simple.
#--------------------------------VERSION 1.2--------------------------------#
#(new) Added dupe function -dupe which creates a replica of the current hologram in the same position.
#(new) Added copy and paste functions for all holo properties. Alowing to copy a property from one holo and place on another.
#(change) Changed standard prints to el super fancio colorPrint to make this project seem like it's actually important.
#(new) -model string function to set the model after creation, might be helpful if you make a mistake.
#(new) -scale x,y,z function for custom scaling by unit amounts. Same as holoScaleUnits().
#(new) -scalem x,y,z function for custom scaling by multiple amounts. Same as holoScale().
#(change) Changed around layout of scaleHolo function to allow multiplier scaling as well as unit scaling.
#--------------------------------------------------------------------------#

if (first() | dupefinished()){
    Version = "Alpha 1.2"
    setName("Simple Holo Model Creator ("+Version+")")
    
    runOnKeys(owner(),1)
    runOnChat(1)
    dsJoinGroup("holoCreator")  
    runOnHTTP(1)
    httpRequest("https://raw.githubusercontent.com/EnyxRB/CodeRelease/master/Expression2/Simple%20Holo%20Model%20Creator")
        
    QTable=array("a")
    QMark = vonEncode(QTable):explode("")[1,string]
    
    function void colorPrint(String:string,Value:string,String2:string){
        printColor(vec(0,255,0),"[SHMC "+Version+"] ",vec(255),String+" ",vec(0,161,255),Value,vec(255)," "+String2)            
    }
    
    colorPrint("Please place down the Holo Creator Slave E2 on the ground","","")
    
    function void number:indexHolo(Model:string){
        Holos:pushNumber(This)
        setName("Simple Holo Model Creator ("+Version+") - "+Holos:count()+" Holograms") 
        CurIndex = Holos:count()
        CurHolo = Holos[Holos:count(),number]
        HoloColor[CurIndex,vector] = vec(255)
        HoloAlpha[CurIndex,number] = 255
        HoloModel[CurIndex,string]=Model        
        if (Holos:exists(LastIndex)){
            holoColor(LastHolo,HoloColor[LastIndex,vector])
        }
        HoloScale[CurIndex,vector] = holoEntity(CurHolo):boxSize()
        holoScaleUnits(CurHolo,HoloScale[CurIndex,vector])
        LastHolo = CurHolo
        LastIndex = CurIndex        
    }
            
    function void number:moveHolo(Vector:vector){
        holoPos(CurHolo,Vector)
        HoloPos[This,vector]=entity():toLocal(Vector)
        colorPrint("Offset:",round(Vector-entity():pos(),3):toString(),"")       
    }
    
    function void number:scaleHolo(Vector:vector,Mirror:number,Multiple:number){
        if (Mirror){
            HoloScale[This,vector]=Vector
            holoScaleUnits(CurHolo,HoloScale[This,vector])
            colorPrint("ScaleUnits:",round(HoloScale[This,vector],3):toString(),"")        
        }
        elseif (Multiple){
            HoloScale[This,vector] = holoEntity(Holos[This,number]):boxSize()*Vector
            holoScaleUnits(CurHolo,HoloScale[This,vector])
            colorPrint("ScaleMultiple:",round(HoloScale[This,vector],3):toString(),"") 
        }
        else{
            HoloScale[This,vector]=HoloScale[This,vector]+Vector 
            holoScaleUnits(CurHolo,HoloScale[This,vector])   
            colorPrint("ScaleUnits:",round(HoloScale[This,vector],3):toString(),"")          
        }                
    }
        
    function void number:colorHolo(Vector:vector){
        HoloColor[This,vector]=Vector
        holoColor(CurHolo,Vector)         
    }
    
    function void number:modelHolo(String:string){
        HoloModel[This,string]=String
        holoModel(CurHolo,String)         
    }    
    
    function void number:angleHolo(Angle:angle,Reset:number,Mirror:number){
        local Ang = ang(0,0,0)
        if (!Reset){
            if (Mirror){
                Ang = Angle        
            }
            else{      
                Ang = holoEntity(CurHolo):angles()+Angle 
            }
        }
        colorPrint("Angle:",round(Ang,3):toString(),"")
        HoloAng[This,angle]=entity():toLocal(Ang)
        holoAng(CurHolo,Ang)    
    }
    
    function void number:alphaHolo(Alpha:number){
        HoloAlpha[This,number]=Alpha
        holoAlpha(CurHolo,Alpha)    
    }
    
    function void number:materializeHolo(String:string){
        HoloMaterial[This,string]=String
        holoMaterial(CurHolo,String)   
    }

    function void number:deleteHolo(){
        holoDelete(CurHolo)
        Holos:removeNumber(This) 
        HoloPos:removeVector(This)  
        HoloAng:removeAngle(This)
        HoloScale:removeVector(This)
        HoloColor:removeVector(This) 
        HoloModel:removeString(This)
        HoloMaterial:removeString(This)
        HoloAlpha:removeNumber(This)
        setName("Simple Holo Model Creator ("+Version+") - "+Holos:count()+" Holograms")
        if (CurIndex>1){
            CurIndex-=1
            CurHolo = Holos[CurIndex,number]
            LastHolo=CurHolo   
            LastIndex = CurIndex           
        }
        elseif (CurHolo<Holos:count()){
            CurIndex+=1
            CurHolo = Holos[CurIndex,number]
            LastHolo=CurHolo
            LastIndex = CurIndex            
        }
        else{
            CurIndex=1
            CurHolo = Holos[CurIndex,number]
            LastHolo=CurHolo
            LastIndex = CurIndex            
        }
        holoColor(CurHolo,vec(255,0,191))
    }
        
    function void setHoloCol(){
        colorPrint("Changing to edit Hologram #",CurHolo:toString(),"") 
        if (Holos:exists(LastIndex)){
            holoColor(LastHolo,HoloColor[LastIndex,vector])
        }
        holoColor(CurHolo,vec(255,0,191))
        LastHolo = CurHolo
        LastIndex = CurIndex          
    }

    function void cycleHolo(Up:number,Down:number){
        
        if (Up){
            if ((CurHolo)<Holos:max()){  
                CurIndex+=1 
                CurHolo = Holos[CurIndex,number]
                setHoloCol()
                LastHolo = CurHolo
                LastIndex = CurIndex  
            }
        }
        elseif (Down){
            if ((CurHolo)>Holos:min()){
                CurIndex-=1
                CurHolo = Holos[CurIndex,number]
                setHoloCol()
                LastHolo = CurHolo
                LastIndex = CurIndex  
            }
        }
              
    }

    function void createCode(){
        Code = "@name "+Filename+"       

if (first()|dupefinished()){"    
    for(I=1,Holos:count()){
Code+= 
"
    holoCreate("+I+",entity():toWorld(vec("+round(HoloPos[I,vector]:x(),3)+","+round(HoloPos[I,vector]:y(),3)+","+round(HoloPos[I,vector]:z(),3)+")))
    holoModel("+I+","+QMark+HoloModel[I,string]+QMark+")
    holoScaleUnits("+I+",vec("+round(HoloScale[I,vector]:x(),3)+","+round(HoloScale[I,vector]:y(),3)+","+round(HoloScale[I,vector]:z(),3)+"))
    holoAng("+I+",entity():toWorld(ang("+round(HoloAng[I,angle]:pitch(),3)+","+round(HoloAng[I,angle]:yaw(),3)+","+round(HoloAng[I,angle]:roll(),3)+")))
    holoParent("+I+",entity())
    holoColor("+I+",vec("+HoloColor[I,vector]:x()+","+HoloColor[I,vector]:y()+","+HoloColor[I,vector]:z()+"))
    holoAlpha("+I+","+HoloAlpha[I,number]+")
    holoMaterial("+I+","+QMark+HoloMaterial[I,string]+QMark+")
    "              
    }
    Code+= "
}"
    Slave:remoteSetCode(Code)
    #fileWrite(">e2shared/"+Filename+".txt",Code)
    colorPrint("Code transfer complete, please save the slave E2:",Filename,"")
    }

    function void createHolo(Model:string){
        Index++
        holoCreate(Index)
        holoCreate(Index)
        holoCreate(Index)
        holoColor(Index,vec(255,0,191))
        holoModel(Index,Model)         
        if (Model!=""){
            if (holoEntity(Index):model()==("models/holograms/cube.mdl")){
                colorPrint("No model found for this hologram, try again...","","")
                holoDelete(Index)    
            }
            else{
                Index:indexHolo(Model)
                colorPrint("Hologram #",Holos:count():toString(),"created sucessfully")
            }
        }
        else{
            Index:indexHolo(Model)
            colorPrint("Hologram #",Holos:count():toString(),"created sucessfully")
        }
    }    
    
    function void number:mirrorHolo(Direction:string){
        if (holoCanCreate()){
            local IsDir = 0
            local Pos = vec(0,0,0)
            MirrorIndex = CurIndex
            local LPos = entity():toLocal(holoEntity(Holos[MirrorIndex,number]):pos())
            if (Direction=="forward"){
                Pos = entity():toWorld(vec(-LPos:x(),LPos:y(),LPos:z()))
                colorPrint("Hologram #",CurHolo:toString()," mirrored across plane forward") 
                IsDir=1
            }
            if (Direction=="right"){
                Pos = entity():toWorld(vec(LPos:x(),-LPos:y(),LPos:z()))  
                colorPrint("Hologram #",CurHolo:toString()," mirrored across plane sideways")
                IsDir=1
            }
            if (Direction=="up"){
                Pos = entity():toWorld(vec(LPos:x(),LPos:y(),-LPos:z())) 
                colorPrint("Hologram #",CurHolo:toString()," mirrored across plane upwards")
                IsDir=1
            }
            if (IsDir){                                     
                local Ang = entity():toLocal(holoEntity(Holos[MirrorIndex,number]):angles())
                createHolo(HoloModel[MirrorIndex,string])
                CurIndex:moveHolo(Pos)
                CurIndex:angleHolo(entity():toWorld(-Ang),0,1)
                CurIndex:colorHolo(HoloColor[MirrorIndex,vector])
                CurIndex:materializeHolo(HoloMaterial[MirrorIndex,string])
                CurIndex:scaleHolo(HoloScale[MirrorIndex,vector],1,0)
                CurIndex:alphaHolo(HoloAlpha[MirrorIndex,number])
                holoColor(CurHolo,vec(255,0,191))
            }
        }
        else{colorPrint("Either hit maximum hologram limit or burst limit","","")}            
    }
    
    function void number:dupeHolo(){
        if (holoCanCreate()){
            MirrorIndex = CurIndex 
            local LPos = entity():toLocal(holoEntity(Holos[MirrorIndex,number]):pos())  
            createHolo(HoloModel[MirrorIndex,string])
            CurIndex:moveHolo(entity():toWorld(LPos))
            CurIndex:angleHolo(HoloAng[MirrorIndex,angle],0,1)
            CurIndex:colorHolo(HoloColor[MirrorIndex,vector])
            CurIndex:materializeHolo(HoloMaterial[MirrorIndex,string])
            CurIndex:scaleHolo(HoloScale[MirrorIndex,vector],1,0)
            CurIndex:alphaHolo(HoloAlpha[MirrorIndex,number])     
            holoColor(CurHolo,vec(255,0,191))
        }
        else{colorPrint("Either hit maximum hologram limit or burst limit","","")}     
    }
    
    Inc = 6 
    IncAng = 45
    Mode = 1
    LastHolo = 999
    LastIndex = 999             
}

if (keyClk(owner())){
    if (owner():keyPressed("pad_6")|owner():keyPressed("pad_4")|owner():keyPressed("pad_8")|owner():keyPressed("pad_5")|owner():keyPressed("pad_minus")|owner():keyPressed("pad_plus")){
        if (holoEntity(CurHolo):isValid()){
            if (Mode==1){                
                local Vec = holoEntity(CurHolo):pos()+(vec(owner():keyPressed("pad_8")-owner():keyPressed("pad_5"),owner():keyPressed("pad_4")-owner():keyPressed("pad_6"),owner():keyPressed("pad_minus")-owner():keyPressed("pad_plus"))*Inc)
                CurIndex:moveHolo(Vec)
            }
            elseif (Mode==2){
                local Vec = (vec(owner():keyPressed("pad_8")-owner():keyPressed("pad_5"),owner():keyPressed("pad_4")-owner():keyPressed("pad_6"),owner():keyPressed("pad_minus")-owner():keyPressed("pad_plus"))*Inc)                
                CurIndex:scaleHolo(Vec,0,0)
            }
            else{
                local Ang = (ang(owner():keyPressed("pad_8")-owner():keyPressed("pad_5"),owner():keyPressed("pad_4")-owner():keyPressed("pad_6"),owner():keyPressed("pad_plus")-owner():keyPressed("pad_minus"))*IncAng)
                CurIndex:angleHolo(Ang,0,0)
            }
        }
    }
    elseif (owner():keyPressed("pad_multiply")|owner():keyPressed("pad_divide")){
        cycleHolo(owner():keyPressed("pad_multiply"),owner():keyPressed("pad_divide"))        
    }    
}

if (chatClk(owner())){   
    local Chat = lastSaid():lower():explode(" ")

    if (Chat[1,string]=="-i"){
        hideChat(1)
        if (holoCanCreate()){
            createHolo(Chat[2,string])
        }
        else{colorPrint("Either hit maximum hologram limit or burst limit","","")}
    }         
    elseif (Chat[1,string]=="-inc"){
        hideChat(1)
        if (Chat[2,string]=="ang"){
            IncAng = Chat[3,string]:toNumber()  
            Mode = 3 
        }
        else{
            Inc = Chat[2,string]:toNumber()
        }   
    } 
    elseif (Chat[1,string]=="-move"){
        hideChat(1)        
        if (Chat[2,string]=="reset"){
            CurIndex:moveHolo(entity():pos())         
        }
        elseif (Chat[2,string]!=""){            
            local XYZ = Chat[2,string]:explode(",")
            local Pos = vec(XYZ[1,string]:toNumber(),XYZ[2,string]:toNumber(),XYZ[3,string]:toNumber())
            local LPos = entity():toLocal(Pos)
            CurIndex:moveHolo(entity():toWorld(Pos))             
        }
        else{
            Mode = 1
            colorPrint("Current mode set to:","Move","") 
        }            
    }         
    elseif (Chat[1,string]=="-scale"){
        hideChat(1)        
        if (Chat[2,string]!=""){
            if (Chat[2,string]=="half"){
                CurIndex:scaleHolo(-HoloScale[CurHolo,vector]/2,0,0)            
            }
            elseif (Chat[2,string]=="double"){
                CurIndex:scaleHolo(HoloScale[CurHolo,vector],0,0)            
            }
            elseif (Chat[2,string]=="reset"){
                CurIndex:scaleHolo(vec(1),0,1)         
            }
            else{
                local XYZ = Chat[2,string]:explode(",")
                CurIndex:scaleHolo(vec(XYZ[1,string]:toNumber(),XYZ[2,string]:toNumber(),XYZ[3,string]:toNumber()),1,0)     
            }
        }
        else{
            Mode = 2
            colorPrint("Current mode set to:","Scale","")
        }
    }
    elseif (Chat[1,string]=="-scalem"){
        hideChat(1)
        local XYZ = Chat[2,string]:explode(",")
        CurIndex:scaleHolo(vec(XYZ[1,string]:toNumber(),XYZ[2,string]:toNumber(),XYZ[3,string]:toNumber()),0,1)         
    }
    elseif (Chat[1,string]=="-ang"){
        hideChat(1)
        if (Chat[2,string]=="reset"){
            CurIndex:angleHolo(ang(0,0,0),1,0)            
        }
        elseif (Chat[2,string]!=""){
            local PYR = Chat[2,string]:explode(",")
            CurIndex:angleHolo(ang(PYR[1,string]:toNumber(),PYR[2,string]:toNumber(),PYR[3,string]:toNumber()),0,1)            
        }
        else{
            Mode = 3
            colorPrint("Current mode set to:","Angle","")
        }        
    }
    elseif (Chat[1,string]=="-model"){
        hideChat(1)
        CurIndex:modelHolo(Chat[2,string])                  
    }
    elseif (Chat[1,string]=="-color"){
        hideChat(1)
        local RGB = Chat[2,string]:explode(",")
        CurIndex:colorHolo(vec(RGB[1,string]:toNumber(),RGB[2,string]:toNumber(),RGB[3,string]:toNumber()))  
    }  
    elseif (Chat[1,string]=="-alpha"){
        hideChat(1)
        CurIndex:alphaHolo(Chat[2,string]:toNumber())    
    }
    elseif (Chat[1,string]=="-mat"){
        hideChat(1)
        CurIndex:materializeHolo(Chat[2,string])
    }
    elseif (Chat[1,string]=="-delete"){
        hideChat(1)
        CurIndex:deleteHolo()
    } 
    elseif (Chat[1,string]=="-mirror"){
        hideChat(1)
        CurIndex:mirrorHolo(Chat[2,string])
    } 
    elseif (Chat[1,string]=="-dupe"){
        hideChat(1)
        CurIndex:dupeHolo()
    }
    elseif (Chat[1,string]=="-copy"){
        hideChat(1)
        if (Chat[2,string]=="mat"){
            CopyMat = HoloMaterial[CurIndex,string]
            colorPrint("Material:",CopyMat," copied")   
        }
        elseif (Chat[2,string]=="color"){
            CopyColor = HoloColor[CurIndex,vector]  
            colorPrint("Color:",CopyColor:toString()," copied")  
        }
        elseif (Chat[2,string]=="model"){
            CopyModel = HoloModel[CurIndex,string]  
            colorPrint("Model:",CopyModel," copied")  
        }
        elseif (Chat[2,string]=="scale"){
            CopyScale = HoloScale[CurIndex,vector] 
            colorPrint("Scale:",CopyScale:toString()," copied")    
        }
        elseif (Chat[2,string]=="pos"){
            CopyPos = entity():toLocal(holoEntity(CurHolo):pos()) 
            colorPrint("Position:",CopyPos:toString()," copied")  
        }
        elseif (Chat[2,string]=="ang"){
            CopyAng = entity():toLocal(holoEntity(CurHolo):angles())   
            colorPrint("Angle:",CopyAng:toString()," copied")
        }
        elseif (Chat[2,string]=="alpha"){
            CopyAlpha = HoloAlpha[CurIndex,number]
            colorPrint("Alpha:",CopyAlpha:toString()," copied")    
        }
    }
    elseif (Chat[1,string]=="-paste"){
        hideChat(1)
        if (Chat[2,string]=="mat"){
            CurIndex:materializeHolo(CopyMat) 
            colorPrint("Material:",CopyMat," pasted onto Hologram #"+CurHolo)     
        }
        elseif (Chat[2,string]=="color"){
            CurIndex:colorHolo(CopyColor)
            colorPrint("Color:",CopyColor:toString()," pasted onto Hologram #"+CurHolo)   
        }
        elseif (Chat[2,string]=="model"){
            CurIndex:modelHolo(CopyModel)  
            colorPrint("Changed Hologram #"+CurHolo+"'s model to:",CopyModel,"")  
        }
        elseif (Chat[2,string]=="scale"){
            CurIndex:scaleHolo(CopyScale,1,0)    
            colorPrint("Scale:",CopyScale:toString()," pasted onto Hologram #"+CurHolo)
        }
        elseif (Chat[2,string]=="pos"){
            CurIndex:moveHolo(entity():toWorld(CopyPos)) 
            colorPrint("Hologram #"+CurHolo+" moved to copied position:",CopyPos:toString(),"") 
        }
        elseif (Chat[2,string]=="ang"){
            CurIndex:angleHolo(entity():toWorld(CopyAng),0,1) 
            colorPrint("Hologram #"+CurHolo+" angled to copied angle:",CopyAng:toString(),"")  
        }
        elseif (Chat[2,string]=="alpha"){
            CurIndex:alphaHolo(CopyAlpha) 
            colorPrint("Hologram #"+CurHolo+" set alpha to copied alpha:",CopyAlpha:toString(),"")  
        }
    }
    elseif (Chat[1,string]=="-finish"){
        if (Chat[2,string]!=""){
            Filename = Chat[2,string]
            hideChat(1)
            if (Slave:isValid()){
                createCode()
            }
            else{colorPrint("You need to spawn the Simple Holo Model Creator Slave E2 first","","")}
        }
    }   
    elseif (Chat[1,string]=="-update"){
        if (UpdateOption==1){
            entity():remoteSetCode(GitCode)    
            UpdateOption=0    
        }    
    }          
      
}

if (dsClk("init")){
    Slave = dsGetSender()
    colorPrint("Slave connected.","","")    
}

if (httpClk()){
    GitCode = httpData():trim()    
    if (GitCode==getCode():trim()){
        printColor(vec(0,255,0),"[SHMC "+Version+"] ",vec(255),"is ",vec(0,161,255),"up to date!")    
    }
    else{
        UpdateOption = 1
        #ifdef entity:remoteUpload(string)
            printColor(vec(0,255,0),"[SHMC "+Version+"] ",vec(255),"is ",vec(200,0,0),"OUT OF DATE!",vec(255),"type",vec(0,161,255)," -update",vec(255)," to automatically update to the newest version.")    
        #else
            printColor(vec(0,255,0),"[SHMC "+Version+"] ",vec(255),"is ",vec(200,0,0),"OUT OF DATE!",vec(255)," get the newest version now at: ",vec(0,161,255),"https://github.com/EnyxRB/CodeRelease/blob/master/Expression2/Simple%20Holo%20Model%20Creator")    
        #endif
    }
    runOnHTTP(0)
}
